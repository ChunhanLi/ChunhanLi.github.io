---
layout:     post
title:      SQL刷题
subtitle:   SQL
date:       2018-11-7
author:     Chunhan Li
header-img: img/post-bg-re-vs-ng2.jpg
catalog: false
tags:
    - SQL
---


1 存在如下的视图：
create view emp_v as select * from employees where emp_no >10005;
如何获取emp_v和employees有相同的数据？
CREATE TABLE `employees` (
`emp_no` int(11) NOT NULL,
`birth_date` date NOT NULL,
`first_name` varchar(14) NOT NULL,
`last_name` varchar(16) NOT NULL,
`gender` char(1) NOT NULL,
`hire_date` date NOT NULL,
PRIMARY KEY (`emp_no`));

```
1.
select em.* from emp_v as ev, employees as em
where ev.emp_no = em.emp_no;

2.
select * from emp_v intersect select * from employees

3.
select * from employees where emp_no in (select emp_no from emp_v)
```

2 存在如下的视图：
create view emp_v as select * from employees where emp_no >10005;
CREATE TABLE `employees` (
`emp_no` int(11) NOT NULL,
`birth_date` date NOT NULL,
`first_name` varchar(14) NOT NULL,
`last_name` varchar(16) NOT NULL,
`gender` char(1) NOT NULL,
`hire_date` date NOT NULL,
PRIMARY KEY (`emp_no`));
获取employees中的行数据，且这些行也存在于emp_v中。注意不能使用intersect关键字。

```
select * from employees where emp_no in (select emp_no from emp_v)
```

3 查找字符串'10,A,B' 中逗号','出现的次数cnt。

```
##如果有中文 最好使用char_length()函数
## length函数统计的是字节数 length('中')在utf8下结果是3 而char_length()是1
select (length('10,A,B') - length(replace('10,A,B',',','')))/length(',') as cnt
```

4 获取Employees中的first_name，查询按照first_name最后两个字母，按照升序进行排列
CREATE TABLE `employees` (
`emp_no` int(11) NOT NULL,
`birth_date` date NOT NULL,
`first_name` varchar(14) NOT NULL,
`last_name` varchar(16) NOT NULL,
`gender` char(1) NOT NULL,
`hire_date` date NOT NULL,
PRIMARY KEY (`emp_no`));

```
#链接：https://www.nowcoder.com/questionTerminal/74d90728827e44e2864cce8b26882105
#来源：牛客网

#本题考查 substr(X,Y,Z) 或 substr(X,Y) 函数的使用。
#其中X是要截取的字符串。Y是字符串的起始位置（注意第一个字符的位置为1，而不为0），取值范围
#是±(1~length(X))，当Y等于length(X)时，则截取最后一个字符；当Y等于负整数-n时，则从倒数
#第n个字符处截取。Z是要截取字符串的长度，取值范围是正整数，若Z省略，则从Y处一直截取到字符
#串末尾；若Z大于剩下的字符串长度，也是截取到字符串末尾为止。
select first_name from employees
order by substr(first_name,-2)
```

5 按照dept_no进行汇总，属于同一个部门的emp_no按照逗号进行连接，结果给出dept_no以及连接出的结果employees
CREATE TABLE `dept_emp` (
`emp_no` int(11) NOT NULL,
`dept_no` char(4) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));

```
#链接：https://www.nowcoder.com/questionTerminal/6e86365af15e49d8abe2c3d4b5126e87
#来源：牛客网

#本题要用到SQLite的聚合函数group_concat(X,Y)，其中X是要连接的字段，Y是连接时用的符号，
#可省略，默认为逗号。此函数必须与 GROUP BY 配合使用。此题以 dept_no 作为分组，将每个分组中不同
#的emp_no用逗号连接起来（即可省略Y）。可参考：
#http://www.sqlite.org/lang_aggfunc.html#groupconcat
#http://blog.csdn.net/langzxz/article/details/16807859

select dept_no, group_concat(emp_no) as employees
from dept_emp group by dept_no
```

6 将id=5以及emp_no=10001的行数据替换成id=5以及emp_no=10005,其他数据保持不变，使用replace实现。
CREATE TABLE IF NOT EXISTS titles_test (
id int(11) not null primary key,
emp_no int(11) NOT NULL,
title varchar(50) NOT NULL,
from_date date NOT NULL,
to_date date DEFAULT NULL);

  insert into titles_test values ('1', '10001', 'Senior Engineer', '1986-06-26', '9999-01-01'),
  ('2', '10002', 'Staff', '1996-08-03', '9999-01-01'),
  ('3', '10003', 'Senior Engineer', '1995-12-03', '9999-01-01'),
  ('4', '10004', 'Senior Engineer', '1995-12-03', '9999-01-01'),
  ('5', '10001', 'Senior Engineer', '1986-06-26', '9999-01-01'),
  ('6', '10002', 'Staff', '1996-08-03', '9999-01-01'),
  ('7', '10003', 'Senior Engineer', '1995-12-03', '9999-01-01');

```
update titles_test
set emp_no = replace(emp_no,10001,10005)
where id = 5
```

7 改表名

```
alter table customers rename to cust_xxxx
rename table customers to cust_xxxx
```

8 将所有获取奖金的员工当前的薪水增加10%。
create table emp_bonus(
emp_no int not null,
recevied datetime not null,
btype smallint not null);
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL, PRIMARY KEY (`emp_no`,`from_date`));

```
update salaries
set salary = 1.1 * salary
where emp_no in (select emp_no from emp_bonus) and to_date = '9999-01-01'

update salaries
set salary = 1.1 * salary
where emp_no in (select bo.emp_no
from emp_bonus as bo inner join salaries as s
on s.emp_no = bo.emp_no and s.to_date = '9999-01-01')
```

9 将employees表中的所有员工的last_name和first_name通过(')连接起来。
CREATE TABLE `employees` (
`emp_no` int(11) NOT NULL,
`birth_date` date NOT NULL,
`first_name` varchar(14) NOT NULL,
`last_name` varchar(16) NOT NULL,
`gender` char(1) NOT NULL,
`hire_date` date NOT NULL,
PRIMARY KEY (`emp_no`));

```
###mysql
select concat(last_name,"'",first_name)
from employees

### sqlite

select last_name || "'" || first_name from employees
```

10 查找排除当前最大、最小salary之后的员工的平均工资avg_salary。
CREATE TABLE `salaries` ( `emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`from_date`));

```
### 错误代码
select (sum(salary) - min(salary) - max(salary))/(count(salary)-2) as avg_salary
from salaries
where to_date = '9999-01-01'

### 难道最大最小只有一个吗？？？？？太年轻了

###正确答案

select avg(salary) as avg_salary
from salaries
where to_date = '9999-01-01'
and salary not in (select max(salary) from salaries where to_date = '9999-01-01')
and salary not in (select min(salary) from salaries where to_date = '9999-01-01')
```

11 查找最晚入职员工的所有信息
CREATE TABLE `employees` (
`emp_no` int(11) NOT NULL,
`birth_date` date NOT NULL,
`first_name` varchar(14) NOT NULL,
`last_name` varchar(16) NOT NULL,
`gender` char(1) NOT NULL,
`hire_date` date NOT NULL,
PRIMARY KEY (`emp_no`));

```
select * from employees
where hire_date = (select max(hire_date) from employees)
```

12 查找入职员工时间排名倒数第三的员工所有信息
CREATE TABLE `employees` (
`emp_no` int(11) NOT NULL,
`birth_date` date NOT NULL,
`first_name` varchar(14) NOT NULL,
`last_name` varchar(16) NOT NULL,
`gender` char(1) NOT NULL,
`hire_date` date NOT NULL,
PRIMARY KEY (`emp_no`));

```
select * from employees
where hire_date = (select distinct hire_date from employees order by hire_date DESC limit 2,1)
```

13 查找各个部门当前(to_date='9999-01-01')领导当前薪水详情以及其对应部门编号dept_no
CREATE TABLE `dept_manager` (
`dept_no` char(4) NOT NULL,
`emp_no` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`from_date`));

```
### 1
select salaries.*, dept_manager.dept_no
from dept_manager, salaries
where dept_manager.emp_no = salaries.emp_no
and dept_manager.to_date = '9999-01-01'
and salaries.to_date = '9999-01-01'
order by emp_no

### 2
select s.*, d.dept_no
from salaries as s inner join dept_manager as d
on s.emp_no = d.emp_no and s.to_date = '9999-01-01'
and d.to_date = '9999-01-01'
order by emp_no


### 3
select s.*, d.dept_no
from salaries as s inner join dept_manager as d
on s.emp_no = d.emp_no
where s.to_date = '9999-01-01' and d.to_date = '9999-01-01'
order by emp_no
```
