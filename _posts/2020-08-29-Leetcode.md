---
layout:     post
title:      Leetcode刷题
subtitle:   
date:       2020-08-29
author:     Midone
header-img: img/post-bg-re-vs-ng2.jpg
catalog: True
tags:
    - 机器学习
---


#### 1.两数之和

```python
#### 双指针+排序 复杂度nlogn
class Solution:
    def twoSum(self, nums, target) :
        left= 0
        right = len(nums) - 1
        sorted_id = sorted(range(len(nums)),key = lambda x:nums[x])
        while right > left:
            if nums[sorted_id[left]] + nums[sorted_id[right]] == target:
                return sorted_id[left],sorted_id[right]
            elif nums[sorted_id[left]] + nums[sorted_id[right]] > target:
                right -=1
            else:
                left +=1


#### 哈希表 时间复杂度N 空间复杂度N
class Solution:
    def twoSum(self, nums, target) :
        dict1 = {}
        for index,_ in enumerate(nums):
            if target - _ in dict1:
                return dict1[target - _],index
            dict1[_] = index
```


#### 633.平方数之和
```python
##### 可以相等 双指针法要想到确定最大值
import math
class Solution:
    def judgeSquareSum(self, c: int) -> bool:
        right = int(math.sqrt(c))+1
        left = 0
        while right >= left:
            if right**2 + left**2 == c:
                return True
            elif  right**2 + left**2 > c:
                right -=1
            else:
                left +=1
        return False
```

#### 345.反转字符串中的元音字母
```python
##### 双指针法
class Solution:
    def reverseVowels(self, s):
        yuanyin = 'aeiouAEIOU'
        set1 = set(list(yuanyin))
        s = list(s)
        left = 0
        right = len(s)-1
        while right > left:
            if s[right] not in set1:
                right -=1
            if s[left] not in set1:
                left +=1
            if s[right] in set1 and s[left] in set1:
                s[right],s[left] = s[left],s[right]
                right -=1
                left +=1
        return ''.join(s)
```

#### 680.验证回文字符串2
```python
####自己写的 有点慢
class Solution:
    def validPalindrome(self, s):
        s = list(s)
        left = 0
        right = len(s)-1
        mark = 0
        mark_1 = True
        mark_2 = True
        while right > left:
            if s[right] == s[left]:
                right -=1
                left +=1
            elif s[right] == s[left+1]:
                left +=1
                mark +=1
            elif s[right-1] == s[left]:
                right -=1
                mark +=1
            else:
                mark_1 = False
                break
            if mark >=2:
                mark_1 = False
                break
        if mark_1:
            return True
        mark = 0
        left = 0
        right = len(s)-1
        while right > left:
            if s[right] == s[left]:
                right -=1
                left +=1
            elif  s[right-1] == s[left]:
                right -=1
                mark +=1
            elif s[right] == s[left+1]:
                left +=1
                mark +=1
            else:
                return False
            if mark >=2:
                return False
        return True
#### 遇到不一样删除左边或者右边的 然后判断剩下的是不是回文字符串

class Solution:
    def validPalindrome(self, s):
        left = 0
        right = len(s) -1
        if s == s[::-1]:
            return True
        while right > left:
            if s[right] == s[left]:
                left +=1
                right -=1
            elif s[right-1] == s[left] or s[left+1] == s[right]:
                a = s[left:(right)]
                b = s[(left+1):(right+1)]
                return a==a[::-1] or b==b[::-1]
            else:
                return False
```