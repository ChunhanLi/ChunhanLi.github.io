### 快排

```python
### 复杂度nlogn
def quick_sort(array, left, right):  
    if left >= right:  
        return  
    low = left  
    high = right  
    key = array[low]  
    while left < right:  
        while left < right and array[right] > key:  
            right -= 1  
        array[left] = array[right]  
        while left < right and array[left] <= key:  
            left += 1  
        array[right] = array[left]  
    array[right] = key  
    quick_sort(array, low, left - 1)  
    quick_sort(array, left + 1, high) 
```

### 堆排序
```python
def max_heapify(heap,heap_size,root):
    '''
    给定某个节点的下标root，这个节点的父节点、左子节点、右子节点的下标都可以被计算出来。
    父节点：(root-1)//2
    左子节点：2*root + 1
    右子节点：2*root + 2  即：左子节点 + 1
    '''
    left = 2 * root +1
    right = 2 * root +2
    max_node = root
    if left < heap_size and heap[left] > heap[max_node]:
        max_node = left
    if right < heap_size and heap[right] > heap[max_node]:
        max_node = right
    if max_node != root:
        heap[root],heap[max_node] = heap[max_node],heap[root]
        max_heapify(heap,heap_size,max_node)

def create_heap(heap):
    n = len(heap)
    for i in range((n-2)//2,-1,-1):
        max_heapify(heap,n,i)
        
def sort_heap(heap):
    create_heap(heap)
    for i in range(len(heap)-1,0,-1):
        heap[0],heap[i] = heap[i],heap[0]
        max_heapify(heap,i,0)
```