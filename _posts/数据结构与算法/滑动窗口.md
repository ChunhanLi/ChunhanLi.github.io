#### 滑动窗口
- 用来解决一些查找满足一定条件的连续区间的性质的问题。由于区间连续，因此当区间发生变化的时候可以通过旧有的计算结果对搜索空间进行剪剪枝

#### 自己的模板

```python
def func():
    left,right = 0,0
    max_min = 0
    while right < len(s):
        把right加上
        while 条件:
            ···
        right +=1
        max_min更新
```

#### 真题
##### 3.无重复字符的最长子串

```python
#### 滑动窗口
class Solution:
    def lengthOfLongestSubstring(self,s):
        set_tmp= set()
        max_len = 0
        cur_len = 0
        left = 0
        for _ in s:
            while _ in set_tmp:
                set_tmp.remove(s[left])
                left +=1
                cur_len -=1
            set_tmp.add(_)
            cur_len +=1
            max_len = max(max_len,cur_len)
            #print(_,max_len)
        return max_len
#### 自己模板写
class Solution:
    def lengthOfLongestSubstring(self,s):
        set_tmp = set()
        left,right = 0,0
        max_len = 0
        while right < len(s):
            if s[right] not in set_tmp:
                set_tmp.add(s[right])
            else:
                while s[right] in set_tmp:
                    set_tmp.remove(s[left])
                    left+=1
                set_tmp.add(s[right])
            max_len = max(max_len,right - left +1)
            right +=1
        return max_len
#### 修改下模板(这题按模板写太丑陋了)
class Solution:
    def lengthOfLongestSubstring(self,s):
        set_tmp = set()
        left,right = 0,0
        max_len = 0
        while right < len(s):
            while s[right] in set_tmp:
                set_tmp.remove(s[left])
                left+=1
            set_tmp.add(s[right])
            max_len = max(max_len,right - left +1)
            right +=1
        return max_len
```
##### 209.长度最小的子数组
```python
### 每次先加最后一个
### 然后再往前删
class Solution:
    def minSubArrayLen(self, s: int, nums: List[int]) -> int:
        left,right = 0,0
        min_len = len(nums)+1
        sum1 = 0
        while right < len(nums):
            sum1 += nums[right]
            while sum1 >=s :
                min_len = min(min_len,right - left +1)
                sum1 -= nums[left]
                left +=1
            right +=1
        if min_len != len(nums)+1:
            return min_len
        else:
            return 0

```

##### 1004 最大连续1的个数3
```python
class Solution:
    def longestOnes(self, A: List[int], K: int) -> int:
        left,right = 0,0
        max_len = 0
        cnt_0 = 0
        while right < len(A):
            if A[right] ==0:
                cnt_0 +=1###第一步是往后推一个
            while cnt_0 >K:###这层条件是否是符合题目意思的条件得看找最大值还是最小值
                if A[left] ==0:
                    cnt_0 -=1
                left +=1
            max_len = max(max_len,right-left+1)
            right +=1        
        return max_len
                
```

##### 76.最小覆盖子串
```python
####这题关键要维护一个n_s去探测是否满足条件
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        left,right = 0,0
        n_s = len(s)
        n_t = len(t)
        min_len = n_s +1
        min_left = 0
        min_right = 0
        dict_t = dict()
        num_s = 0###标记含t中元素的个数
        #dict_s = {}
        for _ in t:
            if _ not in dict_t:
                dict_t[_] = 1
            else:
                dict_t[_] +=1
        while right < n_s:
            if s[right] in dict_t:
                if dict_t[s[right]] > 0:
                    num_s +=1
                dict_t[s[right]] -=1
            while num_s == n_t:
                if right-left +1 < min_len:
                    min_len = right - left +1
                    min_left =left 
                    min_right = right 
                if s[left] in dict_t:
                    if dict_t[s[left]] ==0:
                        num_s -=1
                    dict_t[s[left]] +=1
                left +=1
            right +=1
        return s[min_left:min_right+1] if min_len != n_s+1 else ''

```