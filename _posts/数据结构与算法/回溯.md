### 回溯
解决回溯问题，实际上就是一个决策树的遍历过程。思考3个问题:
1. 路径：就是已经做出的选择
2. 选择列表: 也就是你当前可以做的选择
3. 结束条件: 也就是到达决策树底层，无法在做选择的条件

回溯框架
```
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择

作者：labuladong
链接：https://zhuanlan.zhihu.com/p/93530380
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

- 其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」
- https://zhuanlan.zhihu.com/p/93530380
- 把路径和选择作为决策树每个节点的属性

```
for 选择 in 选择列表:
    # 做选择
    将该选择从选择列表移除
    路径.add(选择)
    backtrack(路径, 选择列表)
    # 撤销选择
    路径.remove(选择)
    将该选择再加入选择列表
```

- https://zhuanlan.zhihu.com/p/51882471
- 结束条件 这里叫出口 一般放在递归函数的
- 递归函数参数 一定要是随着每一次递归操作而发生改变的；需要不破坏当前值，函数就能回溯
- 结果要有个全局变量来保存 不会随着每一次操作而改变（一般要预先定义一个list）
- 看到 全排列，或者 枚举全部解，等类似的 搜索枚举类型题，基本就是 回溯 没跑了。

#### 46.全排列
```python
#### 回溯做法
#### 第一次通过的做法
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        final_list= []
        def backtrack(path,choice):
            if len(choice) == 0:
                final_list.append(path[:])
                return 
            for _ in choice[:]:
                choice.remove(_)
                path.append(_)
                backtrack(path[:], choice[:])
                choice.append(_)
                path.remove(_)
        backtrack([], nums[:])
        return final_list
#### 看了答案
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        final_list= []
        def backtrack(path,choice):
            if len(choice) == 0:
                final_list.append(path[:])
                return 
            for _ in range(len(choice)):
                #### 将选择从选择列表删除
                #### 路径加上选择
                #### 这两步直接在backtrack完成
                backtrack(path+[choice[_]], choice[:_] + choice[_+1:])
                #### 退回 撤销选择
                #### 路径删除
                #### 选择加回来
        backtrack([], nums[:])
        return final_list
```
#### 47.全排列(可以重复)
```python
##### 第一次做解法 不知道如何判断重复 只能用In了 巨慢 但是还是通过了
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        final_list = []
        def backtrack(path,choice):
            if len(choice) ==0 and path not in final_list:
                final_list.append(path)
                return 
            for i in range(len(choice)):
                backtrack(path + [choice[i]], choice[:i]+choice[i+1:])
        backtrack([], nums)
        return final_list 
###### 思考一下为什么会重复 在每次choice的时候 如果有两个数字一样 那么就一定会重复
######  
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        final_list = []
        def backtrack(path,choice):
            if len(choice) ==0:
                final_list.append(path)
                return 
            tmp = set()
            for i in range(len(choice)):
                if choice[i] in tmp:
                    continue 
                tmp.add(choice[i])
                backtrack(path + [choice[i]], choice[:i]+choice[i+1:])
        backtrack([], nums)
        return final_list 
#### 再或者 先将nums排序 如果nums[i] == nums[i-1]时候就剪纸
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        final_list = []
        nums.sort()
        def backtrack(path,choice):
            if len(choice) == 0:
                final_list.append(path)
            for i in range(len(choice)):
                if i>0 and choice[i] == choice[i-1]:
                    continue 
                backtrack(path+[choice[i]], choice[:i]+choice[i+1:])
        backtrack([], nums)
        return final_list 
```